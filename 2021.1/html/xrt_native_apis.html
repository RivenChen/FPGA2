


<!DOCTYPE HTML>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
	<head>
		<meta charset="utf-8">
		
		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
		<link rel="stylesheet" href="https://static.cloud.coveo.com/searchui/v2.4382/css/CoveoFullSearch.css"/>
		<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<meta name="description"/>
		<meta name="keywords"/>
		<meta property="og:title" content=""/>
		<meta property="og:description"/>
		<!-- favicon -->
		<link rel="icon" type="image/vnd.microsoft.icon" href="_static/favicon.ico"/>
		<link rel="shortcut icon" type="image/vnd.microsoft.icon" href="_static/favicon.ico"/>
		<!-- Fonts -->
		<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet" type="text/css"/>

  
  
  
  

  
      <script type="text/javascript" src="_static/js/jquery.min.js"></script>	
	  <script type="text/javascript" src="_static/js/gtm.js"></script>
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
    <script type="text/javascript" src="_static/js/d3dd8c60ed.js"></script>
    <script type="text/javascript" src="_static/js/common-ui-all.min.js"></script>		
    <script type="text/javascript" src="_static/js/header-footer.min.js"></script>	
    <script type="text/javascript" src="_static/js/jquery-ui.min.js"></script>	
    <script type="text/javascript" src="_static/js/CoveoJsSearch.Lazy.min.js"></script>	
    <script type="text/javascript" src="_static/js/linkid.js"></script>		
    <script type="text/javascript" src="_static/js/Searchbox.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/common-ui-all.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/header-footer.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/pro.min.css" media="all" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="XRT Native Library C++ API" href="xrt_native.main.html" />
    <link rel="prev" title="Xilinx OpenCL extension" href="opencl_extension.html" /> 
	</head>
	<body>
		<div class="xilinx-bs3"/>
		<div class="root responsivegrid">
			<div class="aem-Grid aem-Grid--16 aem-Grid--default--16 aem-Grid--large--16 aem-Grid--xlarge--16 aem-Grid--xxlarge--16 aem-Grid--xxxlarge--16 ">
				<div class="xilinxExperienceFragments experiencefragment aem-GridColumn aem-GridColumn--default--12">
					<div class="xf-content-height">
						<div class="aem-Grid aem-Grid--16 aem-Grid--default--16 ">
							<div class="header parbase aem-GridColumn aem-GridColumn--default--12">
								<noindex>
									<header data-component="header">
										<nav class="navbar navbar-default aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid main-nav">
													<div class="row">
														<div class="col-xs-12">
															<div class="logo-column">
																<div class="logo">
																	<a href="https://www.xilinx.com/">
																	<img src="https://www.xilinx.com/etc.clientlibs/site/clientlibs/xilinx/all/resources/imgs/header/xilinx-header-logo.svg" title="Xilinx Inc"/>
																	</a>
																</div>
															</div>
															<div class="navbar-column">
																<div class="navbar navbar-collapse collapse" id="xilinx-main-menu">
																	<div class="mobile-search-container">
																		<div id="headerSearchBox" class="headerSearch"
																			data-component="header-search" 
																			data-redirect-if-empty="false"
																			data-coveo-access-token="xxa237d4dd-f0aa-47fc-9baa-af9121851b33"
																			data-coveo-organization-id="xilinxcomprode2rjoqok">
																			<div class='coveo-search-section'>
																				<div class="CoveoAnalytics" data-search-hub="Site"></div>
																				<ul class="dropdown-menu options">
																					<li class="option" data-label="All" data-action-link="https://www.xilinx.com/search/site-keyword-search.html" data-search-hub="Site">
																						<a href="#">
																						All</a>
																					</li>
																					<li data-label="Silicon Devices" data-action-link="https://www.xilinx.com//products/silicon-devices/si-keyword-search.html" data-search-hub="Product">
																						<a href="#">
																						Silicon Devices</a>
																					</li>
																					<li data-label="Boards and Kits" data-action-link="https://www.xilinx.com//products/boards-and-kits/bk-keyword-search.html" data-search-hub="Product">
																						<a href="#">
																						Boards and Kits</a>
																					</li>
																					<li data-label="Intellectual Property" data-action-link="https://www.xilinx.com//products/intellectual-property/ip-keyword-search.html" data-search-hub="Product">
																						<a href="#">
																						Intellectual Property</a>
																					</li>
																					<li data-label="Support" class="option" data-action-link="https://www.xilinx.com/search/support-keyword-search.html" data-search-hub="Support">
																						<a href="#">
																						Support</a>
																						<ul>
																							<li data-label="Documentation" data-action-link="https://www.xilinx.com//support/documentation-navigation/documentation-keyword-search.html" data-search-hub="Document">
																								<a href="#">
																								Documentation</a>
																							</li>
																							<li data-label="Knowledge Base" data-action-link="https://www.xilinx.com//support/answer-navigation/answer-keyword-search.html" data-search-hub="AnswerRecord">
																								<a href="#">
																								Knowledge Base</a>
																							</li>
																							<li data-label="Community Forums" data-action-link="https://www.xilinx.com/search/forums-keyword-search.html" data-search-hub="Forums">
																								<a href="#">
																								Community Forums</a>
																							</li>
																						</ul>
																					</li>
																					<li data-label="Partners" data-action-link="https://www.xilinx.com//alliance/member-keyword-search.html" data-search-hub="Partner">
																						<a href="#">
																						Partners</a>
																					</li>
																					<li data-label="Videos" data-action-link="https://www.xilinx.com/video/video-keyword-search.html" data-search-hub="Video">
																						<a href="#">
																						Videos</a>
																					</li>
																					<li data-label="Press" data-action-link="https://www.xilinx.com/search/press-keyword-search.html" data-search-hub="Press">
																						<a href="#">
																						Press</a>
																					</li>
																				</ul>
																				<a href="#" class="btn dropdown-toggle value" data-toggle="dropdown"></a>
																				<div class="CoveoSearchbox" data-id="coveosearchbox" data-action-link="https://www.xilinx.com/search/site-keyword-search.html" data-placeholder="Search Xilinx"></div>
																			</div>
																		</div>
																	</div>
																	<ul class="nav navbar-nav nav-justified">
																		<li class="accordion-toggle-icons" data-component="toggle-dropdown">
																			<a href="https://www.xilinx.com/applications.html">
																			Applications</a> 
																		</li>
																		<li class="accordion-toggle-icons" data-component="toggle-dropdown">
																			<a href="https://www.xilinx.com/products/silicon-devices.html">
																			Products</a> 
																		</li>
																		<li class="accordion-toggle-icons" data-component="toggle-dropdown">
																			<a href="https://developer.xilinx.com/">
																			Developers</a> 
																		</li>
																		<li class="accordion-toggle-icons" data-component="toggle-dropdown">
																			<a href="https://www.xilinx.com/support.html">
																			Support</a> 
																		</li>
																		<li class="accordion-toggle-icons" data-component="toggle-dropdown">
																			<a href="https://www.xilinx.com/about/company-overview.html">
																			About</a> 
																		</li>
																	</ul>
																</div>
															</div>
															<script type="text/javascript" src="_static/js/gtm.js"></script>
															<!--<div class="mini-nav">
																<button type="button" data-function="xilinx-mobile-menu" id="nav-toggle" class="navbar-toggle collapsed visible-xs-block" aria-expanded="false">
																<span></span>
																<span></span>
																<span></span>
																<span></span>
																</button>
																<ul class="list-inline">
																	<li class="dropdown user-menu">
																		<button data-toggle="dropdown">
																		<span class="sr-only">Account</span>
																		<span class="fas fa-user"></span>
																		</button>
																		<ul class="dropdown-menu">
																			<li>
																				<a href="https://www.xilinx.com/myprofile/subscriptions.html">
																				My Account</a>
																			</li>
																			<li>
																				<a href="https://www.xilinx.com/registration/create-account.html">
																				Create Account</a>
																			</li>
																			<li>
																				<a href="https://www.xilinx.com/bin/protected/en/signout">
																				Sign Out</a>
																			</li>
																		</ul>
																	</li>
																	<li class="hidden-xs">
																		<button data-function="search-toggle">
																		<span class="sr-only">Search</span>
																		<span class="far fa-search"></span>
																		</button>
																	</li>
																</ul>
															</div>
															-->
															<div class="search-container">
																<div id="headerSearchBox" class="headerSearch"
																	data-component="header-search" 
																	data-redirect-if-empty="false"
																	data-coveo-access-token="xxa237d4dd-f0aa-47fc-9baa-af9121851b33"
																	data-coveo-organization-id="xilinxcomprode2rjoqok">
																	<div class='coveo-search-section'>
																		<div class="CoveoAnalytics" data-search-hub="Site"></div>
																		<ul class="dropdown-menu options">
																			<li class="option" data-label="All" data-action-link="https://www.xilinx.com/search/site-keyword-search.html" data-search-hub="Site">
																				<a href="#">
																				All</a>
																			</li>
																			<li data-label="Silicon Devices" data-action-link="https://www.xilinx.com/products/silicon-devices/si-keyword-search.html" data-search-hub="Product">
																				<a href="#">
																				Silicon Devices</a>
																			</li>
																			<li data-label="Boards and Kits" data-action-link="https://www.xilinx.com/products/boards-and-kits/bk-keyword-search.html" data-search-hub="Product">
																				<a href="#">
																				Boards and Kits</a>
																			</li>
																			<li data-label="Intellectual Property" data-action-link="https://www.xilinx.com/products/intellectual-property/ip-keyword-search.html" data-search-hub="Product">
																				<a href="#">
																				Intellectual Property</a>
																			</li>
																			<li data-label="Support" class="option" data-action-link="https://www.xilinx.com/search/support-keyword-search.html" data-search-hub="Support">
																				<a href="#">
																				Support</a>
																				<ul>
																					<li data-label="Documentation" data-action-link="https://www.xilinx.com/support/documentation-navigation/documentation-keyword-search.html" data-search-hub="Document">
																						<a href="#">
																						Documentation</a>
																					</li>
																					<li data-label="Knowledge Base" data-action-link="https://www.xilinx.com/support/answer-navigation/answer-keyword-search.html" data-search-hub="AnswerRecord">
																						<a href="#">
																						Knowledge Base</a>
																					</li>
																					<li data-label="Community Forums" data-action-link="https://www.xilinx.com/search/forums-keyword-search.html" data-search-hub="Forums">
																						<a href="#">
																						Community Forums</a>
																					</li>
																				</ul>
																			</li>
																			<li data-label="Partners" data-action-link="https://www.xilinx.com/alliance/member-keyword-search.html" data-search-hub="Partner">
																				<a href="#">
																				Partners</a>
																			</li>
																			<li data-label="Videos" data-action-link="https://www.xilinx.com/video/video-keyword-search.html" data-search-hub="Video">
																				<a href="#">
																				Videos</a>
																			</li>
																			<li data-label="Press" data-action-link="https://www.xilinx.com/search/press-keyword-search.html" data-search-hub="Press">
																				<a href="#">
																				Press</a>
																			</li>
																		</ul>
																		<a href="#" class="btn dropdown-toggle value" data-toggle="dropdown"></a>
																		<div class="CoveoSearchbox" data-id="coveosearchbox" data-action-link="https://www.xilinx.com/search/site-keyword-search.html" data-placeholder="Search Xilinx"></div>
																	</div>
																</div>
																<button data-function="search-toggle">
																<span class="sr-only">Search</span>
																<span class="far fa-times"></span>
																</button>
															</div>
														</div>
													</div>
												</div>
											</div>
										</nav>
									</header>
								</noindex>
							</div>
						</div>
					</div>
				</div>
				<div class="parsys aem-GridColumn--xxxlarge--none aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
						<div class="container-fluid">
							<div class="row">
							<div class="col-xs-12">
   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> XRT
          

          
          </a>

          
            
            
              <div class="version">
                2021.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="platforms.html">XRT and Vitis™ Platform Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="system_requirements.html">System Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html">Building the XRT Software Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">XRT Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">Developer Build and Test Instructions</a></li>
</ul>
<p class="caption"><span class="caption-text">Use Model and Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="execution-model.html">Execution Model Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_kernel_executions.html">XRT Controlled Kernel Execution Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiprocess.html">Multi-Process Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="p2p.html">PCIe Peer-to-Peer (P2P)</a></li>
<li class="toctree-l1"><a class="reference internal" href="m2m.html">Memory-to-Memory (M2M)</a></li>
<li class="toctree-l1"><a class="reference internal" href="hm.html">Host Memory Access</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_ini.html">Configuration File xrt.ini</a></li>
</ul>
<p class="caption"><span class="caption-text">Video Acceleration Using XMA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="xma_user_guide.html">XMA Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma_apps_dev.html">Application Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma_plugin_dev.html">Plugin Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="xmakernels.main.html">XMA Upper Edge API Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma.main.html">XMA Lower Edge API Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma_19.2.html">Migration from Legacy XMA</a></li>
</ul>
<p class="caption"><span class="caption-text">User API Library</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="opencl_extension.html">Xilinx OpenCL extension</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">XRT Native APIs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#device-and-xclbin">Device and XCLBIN</a></li>
<li class="toctree-l2"><a class="reference internal" href="#buffers">Buffers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#buffer-allocation-and-deallocation">1. Buffer allocation and deallocation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creating-special-buffers">Creating special Buffers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#creating-buffers-from-the-user-pointer">Creating Buffers from the user pointer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#data-transfer-using-buffers">2. Data transfer using Buffers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#i-data-transfer-between-host-and-device-by-buffer-read-write-api">I. Data transfer between host and device by Buffer read/write API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ii-data-transfer-between-host-and-device-by-buffer-map-api">II. Data transfer between host and device by Buffer map API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iii-data-transfer-between-the-buffers-by-copy-api">III. Data transfer between the buffers by copy API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#miscellaneous-other-buffer-apis">3. Miscellaneous other Buffer APIs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dma-buf-api">DMA-BUF API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sub-buffer-support">Sub-buffer support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buffer-information">Buffer information</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#kernel-and-run">Kernel and Run</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#obtaining-kernel-object-from-xclbin">Obtaining kernel object from XCLBIN</a></li>
<li class="toctree-l3"><a class="reference internal" href="#getting-bank-group-index-of-the-kernel-argument">Getting bank group index of the kernel argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="#executing-the-kernel">Executing the kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="#other-kernel-apis">Other kernel APIs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#user-managed-kernel">User Managed Kernel</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#creating-xrt-ip-object-from-xclbin">Creating <code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code> object from XCLBIN</a></li>
<li class="toctree-l3"><a class="reference internal" href="#allocating-buffers-for-the-ip-inputs-outputs">Allocating buffers for the IP inputs/outputs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reading-and-write-cu-mapped-registers">Reading and write CU mapped registers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#graph">Graph</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#graph-opening-and-closing">Graph Opening and Closing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reset-functions">Reset Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#graph-execution">Graph execution</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#graph-execution-for-a-fixed-number-of-iterations">Graph execution for a fixed number of iterations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#infinite-graph-execution">Infinite Graph Execution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#measuring-aie-cycle-consumed-by-the-graph">Measuring AIE cycle consumed by the Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rtp-runtime-parameter-control">RTP (Runtime Parameter) control</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dma-operation-to-and-from-global-memory-io">DMA operation to and from Global Memory IO</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#xrt-error-api">XRT Error API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="xrt_native.main.html">XRT Native Library C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_native.main.html#id1">XRT Native Library C API</a></li>
</ul>
<p class="caption"><span class="caption-text">XRT Developer's Space</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="platforms_partitions.html">Alveo™ Platform Loading Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="sysfs.html">Linux Sys FileSystem Nodes</a></li>
<li class="toctree-l1"><a class="reference internal" href="formats.html">Binary Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt.main.html">XRT Core Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="ert.main.html">Embedded Runtime Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="mgmt-ioctl.main.html">XCLMGMT (PCIe Management Physical Function) Driver Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="xocl_ioctl.main.html">XOCL (PCIe User Physical Function) Driver Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="zocl_ioctl.main.html">ZOCL Driver Interfaces</a></li>
</ul>
<p class="caption"><span class="caption-text">Tools and Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="xclbintools.html">xclbinutil</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbutil.html">xbutil</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbmgmt.html">xbmgmt</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbutil2.html">xbutil (Next Generation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbmgmt2.html">xbmgmt (Next Generation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbtools_map.html">Legacy to new map</a></li>
</ul>
<p class="caption"><span class="caption-text">Building Platforms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="yocto.html">XRT Setup for Embedded Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">Developer Build and Test Instructions</a></li>
</ul>
<p class="caption"><span class="caption-text">Cloud Support</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mailbox.main.html">Mailbox Subdevice Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="mailbox.proto.html">Mailbox Inter-domain Communication Protocol</a></li>
<li class="toctree-l1"><a class="reference internal" href="cloud_vendor_support.html">MSD/MPD and Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="vsec.html">Accessing vsec within VM</a></li>
</ul>
<p class="caption"><span class="caption-text">Security</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="security.html">Security of Alveo Platform</a></li>
</ul>
<p class="caption"><span class="caption-text">Debug and Faqs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="debug-faq.html">XRT/Board Debug FAQ</a></li>
</ul>

            
			<p class="caption"><span class="caption-text">This Page</span></p>
				<ul class="current">
				  <li class="toctree-l1"><a href="_sources/xrt_native_apis.rst.txt"
						rel="nofollow">Show Source</a></li>
					<li class="toctree-l1"><a href="https://github.com/Xilinx/XRT/blob/master/src/runtime_src/doc/toc/xrt_native_apis.rst"
						   rel="nofollow">View on GitHub</a></li>						
				</ul>
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">XRT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>XRT Native APIs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/xrt_native_apis.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="xrt-native-apis">
<span id="xrt-native-apis-rst"></span><h1>XRT Native APIs<a class="headerlink" href="#xrt-native-apis" title="Permalink to this headline">¶</a></h1>
<p>From 2020.2 release XRT provides a new XRT API set in C, C++, and Python flavor.</p>
<p>To use the native XRT APIs, the host application must link with the <strong>xrt_coreutil</strong> library.
Compiling host code with XRT native C++ API requires C++ standard with -std=c++14 or newer.
On GCC version older than 4.9.0, please use -std=c++1y instead because -std=c++14 is introduced to GCC from 4.9.0.</p>
<p>Example g++ command</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>g++ -g -std<span class="o">=</span>c++14 -I<span class="nv">$XILINX_XRT</span>/include -L<span class="nv">$XILINX_XRT</span>/lib -o host.exe host.cpp -lxrt_coreutil -pthread
</pre></div>
</div>
<p>The XRT native API supports both the C and C++ flavor of APIs. For general host code development, C++-based APIs are recommended, hence this document only describes the C++-based API interfaces. The full Doxygen generated C and C++ API documentation can be found in <a class="reference external" href="./xrt_native.main.rst">./xrt_native.main.rst</a>.</p>
<p>The C++ Class objects used for the APIs are</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 21%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>C++ Class</p></th>
<th class="head"><p>Header files</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Device</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">xrt::device</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;xrt/xrt_device.h&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>XCLBIN</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">xrt::xclbin</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;experimental/xrt_xclbin.h&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Buffer</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;xrt/xrt_bo.h&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Kernel</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;xrt/xrt_kernel.h&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Run</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">xrt::run</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;xrt/xrt_kernel.h&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>User-managed Kernel</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;experimental/xrt_ip.h&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Graph</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">xrt::graph</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;experimental/aie.h&gt;</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;experimental/graph.h&gt;</span></code></p>
</td>
</tr>
</tbody>
</table>
<p>Majority of the core data structures are defined inside in the header files at <code class="docutils literal notranslate"><span class="pre">$XILINX_XRT/include/xrt/</span></code> directory. Few newer features such as <code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code>, <code class="docutils literal notranslate"><span class="pre">xrt::aie</span></code> related header files are inside <code class="docutils literal notranslate"><span class="pre">$XILINX_XRT/include/experimental</span></code> directory. The API interfaces that are in the experimental folder are subject to breaking changes.</p>
<p>The common host code flow using the above data structures is as below</p>
<ul class="simple">
<li><p>Open Xilinx <strong>Device</strong> and Load the <strong>XCLBIN</strong></p></li>
<li><p>Create <strong>Buffer</strong> objects to transfer data to kernel inputs and outputs</p></li>
<li><p>Use the Buffer class member functions for the data transfer between host and device (before and after the kernel execution).</p></li>
<li><p>Use <strong>Kernel</strong> and <strong>Run</strong> objects to offload and manage the compute-intensive tasks running on FPGA.</p></li>
</ul>
<p>Below we will walk through the common API usage to accomplish the above tasks.</p>
<div class="section" id="device-and-xclbin">
<h2>Device and XCLBIN<a class="headerlink" href="#device-and-xclbin" title="Permalink to this headline">¶</a></h2>
<p>Device and XCLBIN class provide fundamental infrastructure-related interfaces. The primary objective of the device and XCLBIN related APIs are</p>
<ul class="simple">
<li><p>Open a Device</p></li>
<li><p>Load compiled kernel binary (or XCLBIN) onto the device</p></li>
</ul>
<p>The simplest code to load an XCLBIN as below</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">10 </span>     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dev_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno">11 </span>     <span class="k">auto</span> <span class="n">device</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">device</span><span class="p">(</span><span class="n">dev_index</span><span class="p">);</span>
<span class="lineno">12 </span>     <span class="k">auto</span> <span class="n">xclbin_uuid</span> <span class="o">=</span> <span class="n">device</span><span class="p">.</span><span class="n">load_xclbin</span><span class="p">(</span><span class="s">&quot;kernel.xclbin&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The above code block shows</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">xrt::device</span></code> class’s constructor is used to open the device (enumerated as 0)</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::device::load_xclbin</span></code> is used to load the XCLBIN from the filename.</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::device::load_xclbin</span></code> returns the XCLBIN UUID, which is required to open the kernel (refer the Kernel Section).</p></li>
</ul>
<p>The class constructor <code class="docutils literal notranslate"><span class="pre">xrt::device::device(const</span> <span class="pre">std::string&amp;</span> <span class="pre">bdf)</span></code> also supports opening a device object from a Pcie BDF passed as a string.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">10 </span>     <span class="k">auto</span> <span class="n">device</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">device</span><span class="p">(</span><span class="s">&quot;0000:03:00.1&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::device::get_info()</span></code> is a useful member function to obtain necessary information about a device. Some of the information such as Name, BDF can be used to select a specific device to load an XCLBIN</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">10 </span>     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;device name:     &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">device</span><span class="p">.</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">xrt</span><span class="o">::</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">name</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="lineno">11 </span>     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;device bdf:      &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">device</span><span class="p">.</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">xrt</span><span class="o">::</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">bdf</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="buffers">
<h2>Buffers<a class="headerlink" href="#buffers" title="Permalink to this headline">¶</a></h2>
<p>Buffers are primarily used to transfer the data between the host and the device. The Buffer related APIs are discussed in the following three subsections</p>
<ol class="arabic simple">
<li><p>Buffer allocation and deallocation</p></li>
<li><p>Data transfer using Buffers</p></li>
<li><p>Miscellaneous other Buffer APIs</p></li>
</ol>
<div class="section" id="buffer-allocation-and-deallocation">
<h3>1. Buffer allocation and deallocation<a class="headerlink" href="#buffer-allocation-and-deallocation" title="Permalink to this headline">¶</a></h3>
<p>The C++ interface for buffers as below</p>
<p>The class constructor <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> is mainly used to allocates a buffer object 4K aligned. By default, a regular buffer is created (optionally the user can create other types of buffers by providing a flag).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">15 </span>     <span class="k">auto</span> <span class="n">bank_grp_arg0</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">.</span><span class="n">group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// Memory bank index for kernel argument 0</span>
<span class="lineno">16 </span>     <span class="k">auto</span> <span class="n">bank_grp_arg1</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">.</span><span class="n">group_id</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Memory bank index for kernel argument 1</span>
<span class="lineno">17 </span>
<span class="lineno">18 </span>     <span class="k">auto</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">buffer_size_in_bytes</span><span class="p">,</span><span class="n">bank_grp_arg0</span><span class="p">);</span>
<span class="lineno">19 </span>     <span class="k">auto</span> <span class="n">output_buffer</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">buffer_size_in_bytes</span><span class="p">,</span> <span class="n">bank_grp_arg1</span><span class="p">);</span>
</pre></div>
</div>
<p>In the above code <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> buffer objects are created using the class constructor. Please note the following</p>
<ul class="simple">
<li><p>As no special flags are used a regular buffer will be created. Regular buffer is most common type of buffer that has a host backing pointer allocated by user space in heap memory and a device buffer allocated in the specified memory bank.</p></li>
<li><p>The second argument specifies the buffer size.</p></li>
<li><p>The third argument is used to specify the enumerated memory bank index (to specify the buffer location) where the buffer should be allocated. There are two ways to specify the memory bank index</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>Through kernel arguments: In the above example, the <code class="docutils literal notranslate"><span class="pre">xrt::kernel::group_id()</span></code> member function is used to pass the memory bank index. This member function accept kernel argument-index and automatically detect corresponding memory bank index by inspecting XCLBIN.</p></li>
<li><p>Passing Memory bank index:  The <code class="docutils literal notranslate"><span class="pre">xrt::kernel::group_id()</span></code> also accepts the direct memory bank index (as observed from <code class="docutils literal notranslate"><span class="pre">xbutil</span> <span class="pre">examine</span> <span class="pre">--report</span> <span class="pre">memory</span></code> output).</p></li>
</ul>
</div></blockquote>
<div class="section" id="creating-special-buffers">
<h4>Creating special Buffers<a class="headerlink" href="#creating-special-buffers" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::bo()</span></code> constructors accept multiple other buffer flags those are described using <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> argument with the following enumerator values</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::normal</span></code>: Regular buffer (default)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::device_only</span></code>: Device only buffer (meant to be used only by the kernel, there is no host backing pointer).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::host_only</span></code>: Host only buffer (buffer resides in the host memory directly transferred to/from the kernel)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::p2p</span></code>: P2P buffer, A special type of device-only buffer capable of peer-to-peer transfer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::cacheable</span></code>: Cacheable buffer can be used when the host CPU frequently accessing the buffer (applicable for edge platform).</p></li>
</ul>
<p>The below example shows creating a P2P buffer on a device memory bank connected to argument 3 of the kernel.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">15 </span>     <span class="k">auto</span> <span class="n">p2p_buffer</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">buffer_size_in_byte</span><span class="p">,</span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">p2p</span><span class="p">,</span> <span class="n">kernel</span><span class="p">.</span><span class="n">group_id</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="creating-buffers-from-the-user-pointer">
<h4>Creating Buffers from the user pointer<a class="headerlink" href="#creating-buffers-from-the-user-pointer" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::bo()</span></code> constructor can also be called using a pointer provided by the user. The user pointer must be aligned to 4K boundary.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">15 </span>     <span class="c1">// Host Memory pointer aligned to 4K boundary</span>
<span class="lineno">16 </span>     <span class="kt">int</span> <span class="o">*</span><span class="n">host_ptr</span><span class="p">;</span>
<span class="lineno">17 </span>     <span class="n">posix_memalign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host_ptr</span><span class="p">,</span><span class="mi">4096</span><span class="p">,</span><span class="n">MAX_LENGTH</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="lineno">18 </span>
<span class="lineno">19 </span>     <span class="c1">// Sample example filling the allocated host memory</span>
<span class="lineno">20 </span>     <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_LENGTH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">21 </span>     <span class="n">host_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// whatever</span>
<span class="lineno">22 </span>     <span class="p">}</span>
<span class="lineno">23 </span>
<span class="lineno">24 </span>     <span class="k">auto</span> <span class="n">mybuf</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span> <span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">host_ptr</span><span class="p">,</span> <span class="n">MAX_LENGTH</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">kernel</span><span class="p">.</span><span class="n">group_id</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="data-transfer-using-buffers">
<h3>2. Data transfer using Buffers<a class="headerlink" href="#data-transfer-using-buffers" title="Permalink to this headline">¶</a></h3>
<p>XRT Buffer API library provides a rich set of APIs helping the data transfers between the host and the device, between the buffers, etc. We will discuss the following data transfer style</p>
<ol class="upperroman simple">
<li><p>Data transfer between host and device by Buffer read/write API</p></li>
<li><p>Data transfer between host and device by Buffer map API</p></li>
<li><p>Data transfer between buffers by copy API</p></li>
</ol>
<div class="section" id="i-data-transfer-between-host-and-device-by-buffer-read-write-api">
<h4>I. Data transfer between host and device by Buffer read/write API<a class="headerlink" href="#i-data-transfer-between-host-and-device-by-buffer-read-write-api" title="Permalink to this headline">¶</a></h4>
<p>To transfer the data from the host to the device, the user first needs to update the host-side buffer backing pointer followed by a DMA transfer to the device.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> class has following member functions for the same functionality</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::write()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::sync()</span></code> with flag <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_TO_DEVICE</span></code></p></li>
</ol>
<p>To transfer the data from the device to the host, the steps are reversed, the user first needs to do a DMA transfer from the device followed by the reading data from the host-side buffer backing pointer.</p>
<p>The corresponding <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> class’s member functions are</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::sync()</span></code> with flag <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_FROM_DEVICE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::read()</span></code></p></li>
</ol>
<p>Code example of transferring data from the host to the device</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">20 </span>     <span class="k">auto</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">buffer_size_in_bytes</span><span class="p">,</span> <span class="n">bank_grp_idx_0</span><span class="p">);</span>
<span class="lineno">21 </span>     <span class="c1">// Prepare the input data</span>
<span class="lineno">22 </span>     <span class="kt">int</span> <span class="n">buff_data</span><span class="p">[</span><span class="n">data_size</span><span class="p">];</span>
<span class="lineno">23 </span>     <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">data_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">24 </span>         <span class="n">buff_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="lineno">25 </span>     <span class="p">}</span>
<span class="lineno">26 </span>
<span class="lineno">27 </span>     <span class="n">input_buffer</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">buff_data</span><span class="p">);</span>
<span class="lineno">28 </span>     <span class="n">input_buffer</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="p">);</span>
</pre></div>
</div>
<p>Note the C++ <code class="docutils literal notranslate"><span class="pre">xrt::bo::sync</span></code>, <code class="docutils literal notranslate"><span class="pre">xrt::bo::write</span></code>, <code class="docutils literal notranslate"><span class="pre">xrt::bo::read</span></code> etc has overloaded version that can be used for partial buffer sync/read/write by specifying the size and the offset. For the above code example, the full buffer size and offset=0 are assumed as default arguments.</p>
<p>Also note that if the buffer is created through the user-pointer, the <code class="docutils literal notranslate"><span class="pre">xrt::bo::write</span></code> or <code class="docutils literal notranslate"><span class="pre">xrt::bo::read</span></code> is not required before or after the <code class="docutils literal notranslate"><span class="pre">xrt::bo::sync</span></code> call.</p>
</div>
<div class="section" id="ii-data-transfer-between-host-and-device-by-buffer-map-api">
<h4>II. Data transfer between host and device by Buffer map API<a class="headerlink" href="#ii-data-transfer-between-host-and-device-by-buffer-map-api" title="Permalink to this headline">¶</a></h4>
<p>The API <code class="docutils literal notranslate"><span class="pre">xrt::bo::map()</span></code> allows mapping the host-side buffer backing pointer to a user pointer. The host code can subsequently exercise the user pointer for the data reads and writes. However, after writing to the mapped pointer (or before reading from the mapped pointer) the API <code class="docutils literal notranslate"><span class="pre">xrt::bo::sync()</span></code> should be used with direction flag for the DMA operation.</p>
<p>Code example of transferring data from the host to the device by this approach</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">20 </span>     <span class="k">auto</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">buffer_size_in_bytes</span><span class="p">,</span> <span class="n">bank_grp_idx_0</span><span class="p">);</span>
<span class="lineno">21 </span>     <span class="k">auto</span> <span class="n">input_buffer_mapped</span> <span class="o">=</span> <span class="n">input_buffer</span><span class="p">.</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">();</span>
<span class="lineno">22 </span>
<span class="lineno">23 </span>     <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">data_size</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">24 </span>         <span class="n">input_buffer_mapped</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="lineno">25 </span>     <span class="p">}</span>
<span class="lineno">26 </span>
<span class="lineno">27 </span>     <span class="n">input_buffer</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="iii-data-transfer-between-the-buffers-by-copy-api">
<h4>III. Data transfer between the buffers by copy API<a class="headerlink" href="#iii-data-transfer-between-the-buffers-by-copy-api" title="Permalink to this headline">¶</a></h4>
<p>XRT provides <code class="docutils literal notranslate"><span class="pre">xrt::bo::copy()</span></code> API for deep copy between the two buffer objects if the platform supports a deep-copy (for detail refer M2M feature described in <a class="reference internal" href="m2m.html#m2m-rst"><span class="std std-ref">Memory-to-Memory (M2M)</span></a>). If deep copy is not supported by the platform the data transfer happens by shallow copy (the data transfer happens via host).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">25 </span>     <span class="n">dst_buffer</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">src_buffer</span><span class="p">,</span> <span class="n">copy_size_in_bytes</span><span class="p">);</span>
</pre></div>
</div>
<p>The API <code class="docutils literal notranslate"><span class="pre">xrt::bo::copy()</span></code> also has overloaded versions to provide a different offset than 0 for both the source and the destination buffer.</p>
</div>
</div>
<div class="section" id="miscellaneous-other-buffer-apis">
<h3>3. Miscellaneous other Buffer APIs<a class="headerlink" href="#miscellaneous-other-buffer-apis" title="Permalink to this headline">¶</a></h3>
<p>This section describes a few other specific use-cases using buffers.</p>
<div class="section" id="dma-buf-api">
<h4>DMA-BUF API<a class="headerlink" href="#dma-buf-api" title="Permalink to this headline">¶</a></h4>
<p>XRT provides Buffer export and import APIs primarily used for sharing buffer across devices (P2P application) and processes.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::export_buffer()</span></code>: Export the buffer to an exported buffer handle</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo()</span></code> constructor: Allocate a BO imported from exported buffer handle</p></li>
</ul>
<p>Consider the situation of exporting buffer from device 1 to device 2.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">18 </span>     <span class="k">auto</span> <span class="n">buffer_exported</span> <span class="o">=</span> <span class="n">buffer_device_1</span><span class="p">.</span><span class="n">export_buffer</span><span class="p">();</span>
<span class="lineno">19 </span>     <span class="k">auto</span> <span class="n">buffer_device_2</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device_2</span><span class="p">,</span> <span class="n">buffer_exported</span><span class="p">);</span>
</pre></div>
</div>
<p>In the above example</p>
<ul class="simple">
<li><p>The buffer buffer_device_1 is a buffer allocated on device 1</p></li>
<li><p>buffer_device_1 is exported by the member function <code class="docutils literal notranslate"><span class="pre">xrt::bo::export_buffer</span></code></p></li>
<li><p>The new buffer buffer_device_2 is imported for device_2 by the constructor <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code></p></li>
</ul>
</div>
<div class="section" id="sub-buffer-support">
<h4>Sub-buffer support<a class="headerlink" href="#sub-buffer-support" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> class constructor can also be used to allocate a sub-buffer from a parent buffer by specifying a start offset and the size.</p>
<p>In the example below a sub-buffer is created from a parent buffer of size 4 bytes starting from its offset 0</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">18 </span>     <span class="kt">size_t</span> <span class="n">sub_buffer_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="lineno">19 </span>     <span class="kt">size_t</span> <span class="n">sub_buffer_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno">20 </span>
<span class="lineno">21 </span>     <span class="k">auto</span> <span class="n">sub_buffer</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">parent_buffer</span><span class="p">,</span> <span class="n">sub_buffer_size</span><span class="p">,</span> <span class="n">sub_buffer_offset</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="buffer-information">
<h4>Buffer information<a class="headerlink" href="#buffer-information" title="Permalink to this headline">¶</a></h4>
<p>XRT provides few other API Class member functions to obtain information related to the buffer.</p>
<ul class="simple">
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::bo::size()</span></code>: Size of the buffer</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::bo::address()</span></code> : Physical address of the buffer</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="kernel-and-run">
<h2>Kernel and Run<a class="headerlink" href="#kernel-and-run" title="Permalink to this headline">¶</a></h2>
<p>To execute a kernel on a device, a kernel class (<code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code>) object has to be created from currently loaded xclbin.  The kernel object can be used to execute the kernel function on the hardware instance (Compute Unit or CU) of the kernel.</p>
<p>A Run object (<code class="docutils literal notranslate"><span class="pre">xrt::run</span></code>) represents an execution of the kernel. Upon finishing the kernel execution, the Run object can be reused to invoke the same kernel function if desired.</p>
<p>The following topics are discussed below</p>
<ul class="simple">
<li><p>Obtaining kernel object from XCLBIN</p></li>
<li><p>Getting the bank group index of a kernel argument</p></li>
<li><p>Execution of kernel and dealing with the associated run</p></li>
<li><p>Other kernel related API</p></li>
</ul>
<div class="section" id="obtaining-kernel-object-from-xclbin">
<h3>Obtaining kernel object from XCLBIN<a class="headerlink" href="#obtaining-kernel-object-from-xclbin" title="Permalink to this headline">¶</a></h3>
<p>The kernel object is created from the device, XCLBIN UUID and the kernel name using <code class="docutils literal notranslate"><span class="pre">xrt::kernel()</span></code> constructor as shown below</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">35 </span>     <span class="k">auto</span> <span class="n">xclbin_uuid</span> <span class="o">=</span> <span class="n">device</span><span class="p">.</span><span class="n">load_xclbin</span><span class="p">(</span><span class="s">&quot;kernel.xclbin&quot;</span><span class="p">);</span>
<span class="lineno">36 </span>     <span class="k">auto</span> <span class="n">krnl</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">kernel</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Note</strong>: A single kernel object (when created by a kernel name) can be used to execute multiple CUs as long as CUs are having identical interface connectivity. If all the CUs of the kernel are not having identical connectivity, XRT assigns a subset of CUs (one or more CUs with identical connectivity) to the created kernel object and discards the rest of the CUs (discarded CUs are not used during the execution of a kernel).  For this type of situation creating a kernel object using mangled CU names can be more useful.</p>
<p>As an example, assume a kernel name is foo having 3 CUs foo_1, foo_2, foo_3. The CUs foo_1 and foo_2 are connected to DDR bank 0, but the CU foo_3 is connected to DDR bank 1.</p>
<ul class="simple">
<li><p>Opening kernel object for foo_1 and foo_2 (as they have identical interface connection)</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="lineno">35 </span>     <span class="n">krnl_obj_1_2</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">kernel</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="s">&quot;foo:{foo_1,foo_2}&quot;</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Opening kernel object for foo_3</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="lineno">35 </span>     <span class="n">krnl_obj_3</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">kernel</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="s">&quot;foo:{foo_3}&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="getting-bank-group-index-of-the-kernel-argument">
<h3>Getting bank group index of the kernel argument<a class="headerlink" href="#getting-bank-group-index-of-the-kernel-argument" title="Permalink to this headline">¶</a></h3>
<p>We have seen in the Buffer creation section that it is required to provide the buffer location during the buffer creation. The member function <code class="docutils literal notranslate"><span class="pre">xrt::kernel::group_id()</span></code> returns the memory bank index (or id) of a specific argument of the kernel. This id is passed as a parameter of <code class="docutils literal notranslate"><span class="pre">xrt::bo()</span></code> constructor to create the buffer on the same memory bank.</p>
<p>Let us review the example below where the buffer is allocated for the kernel’s first (argument index 0) argument.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">15 </span>     <span class="k">auto</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">buffer_size_in_bytes</span><span class="p">,</span> <span class="n">kernel</span><span class="p">.</span><span class="n">group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</pre></div>
</div>
<p>If the kernel bank index is ambiguous then <code class="docutils literal notranslate"><span class="pre">kernel.group_id()</span></code> returns the last memory bank index in the list it maintains. This is the case when the kernel has multiple CU with different connectivity for that argument. For example, let’s assume a kernel argument (argument 0) is connected to memory bank 0, 1, 2 (for 3 CUs), then <code class="docutils literal notranslate"><span class="pre">kernel.group_id(0)</span></code> will return the last index from the group {0,1,2}, i.e. 2. As a result the buffer is created on the memory bank 2, so the buffer cannot be used for the CU0 and CU1.</p>
<p>However, in the above situation, the user can always create 3 distinct kernel objects corresponds to 3 CUs (by using the <code class="docutils literal notranslate"><span class="pre">{kernel_name:{cu_name(s)}}</span></code> for xrt::kernel constructor) to execute the CUs by separate <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> objects.</p>
</div>
<div class="section" id="executing-the-kernel">
<h3>Executing the kernel<a class="headerlink" href="#executing-the-kernel" title="Permalink to this headline">¶</a></h3>
<p>Execution of the kernel is associated with a <strong>Run</strong> object. The kernel can be executed by the <code class="docutils literal notranslate"><span class="pre">xrt::kernel::operator()</span></code> that takes all the kernel arguments in order. The kernel execution API returns a run object corresponding to the execution.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">50 </span>     <span class="c1">// 1st kernel execution</span>
<span class="lineno">51 </span>     <span class="k">auto</span> <span class="n">run</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">buf_a</span><span class="p">,</span> <span class="n">buf_b</span><span class="p">,</span> <span class="n">scalar_1</span><span class="p">);</span>
<span class="lineno">52 </span>     <span class="n">run</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
<span class="lineno">53 </span>
<span class="lineno">54 </span>     <span class="c1">// 2nd kernel execution with just changing 3rd argument</span>
<span class="lineno">55 </span>     <span class="n">run</span><span class="p">.</span><span class="n">set_arg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">scalar_2</span><span class="p">);</span> <span class="c1">// Arguments are specified starting from 0</span>
<span class="lineno">56 </span>     <span class="n">run</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
<span class="lineno">57 </span>     <span class="n">run</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> class provides <strong>overloaded operator ()</strong> to execute the kernel with a comma-separated list of arguments.</p>
<p>The above c++ code block is demonstrating</p>
<ul class="simple">
<li><p>The kernel execution using the <code class="docutils literal notranslate"><span class="pre">xrt::kernel()</span></code> operator with the list of arguments that returns a <code class="docutils literal notranslate"><span class="pre">xrt::run</span></code> object. This is an asynchronous API and returns after submitting the task.</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::run::wait()</span></code> is used to block the current thread until the current execution is finished.</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::run::set_arg()</span></code> is used to set one or more kernel argument(s) before the next execution. In the example above, only the last (3rd) argument is changed.</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::run::start()</span></code> is used to start the next kernel execution with new argument(s).</p></li>
</ul>
</div>
<div class="section" id="other-kernel-apis">
<h3>Other kernel APIs<a class="headerlink" href="#other-kernel-apis" title="Permalink to this headline">¶</a></h3>
<p><strong>Obtaining the run object before execution</strong>: Example of the previous section shows to obtain a <code class="docutils literal notranslate"><span class="pre">xrt::run</span></code> object when the kernel is executed (kernel execution returns a run object). However, a <code class="docutils literal notranslate"><span class="pre">xrt::run</span></code> object can be obtained even before the kernel execution. The flow is as below</p>
<ul class="simple">
<li><p>Open a Run object by the <code class="docutils literal notranslate"><span class="pre">xrt::run</span></code> constructor with a kernel argument).</p></li>
<li><p>Set the kernel arguments associated for the next execution by the member function <code class="docutils literal notranslate"><span class="pre">xrt::run::set_arg()</span></code>.</p></li>
<li><p>Execute the kernel by the member function <code class="docutils literal notranslate"><span class="pre">xrt::run::start()</span></code>.</p></li>
<li><p>Wait for the execution finish by the member function <code class="docutils literal notranslate"><span class="pre">xrt::run::wait()</span></code>.</p></li>
</ul>
<p><strong>Timeout while wait for kernel finish</strong>: The member function <code class="docutils literal notranslate"><span class="pre">xrt::run::wait()</span></code> blocks the current thread until the kernel execution finishes. To specify a timeout supported API <code class="docutils literal notranslate"><span class="pre">xrt::run::wait()</span></code> also accepts a timeout in millisecond unit.</p>
</div>
</div>
<div class="section" id="user-managed-kernel">
<h2>User Managed Kernel<a class="headerlink" href="#user-managed-kernel" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> is used to execute the kernels with standard control interface through AXI-Lite control registers. These standard control interfaces are well defined and understood by XRT but transparent to the user. These XRT managed kernels should always be represented by <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> objects in the host code.</p>
<p>The XRT also supports custom control interface for a kernel. These type of kernels (a.k.a User-Managed Kernel) must be managed by the user by writing/reading to/from the AXI-Lite registers controlling these kernels. To differentiate from the XRT managed kernel, class <code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code> is used to specify a user-managed kernel inside the user host code.</p>
<div class="section" id="creating-xrt-ip-object-from-xclbin">
<h3>Creating <code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code> object from XCLBIN<a class="headerlink" href="#creating-xrt-ip-object-from-xclbin" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code> object creation is very similar to creating a kernel.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">35 </span>     <span class="k">auto</span> <span class="n">xclbin_uuid</span> <span class="o">=</span> <span class="n">device</span><span class="p">.</span><span class="n">load_xclbin</span><span class="p">(</span><span class="s">&quot;kernel.xclbin&quot;</span><span class="p">);</span>
<span class="lineno">36 </span>     <span class="k">auto</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">ip</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="s">&quot;ip_name&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>An ip object can only be opened in exclusive mode. That means at a time, only one thread/process can access IP at the same time. This is required for a safety reason because multiple threads/processes reading/writing to the AXI-Lite registers at the same time potentially leads to a race situation.</p>
</div>
<div class="section" id="allocating-buffers-for-the-ip-inputs-outputs">
<h3>Allocating buffers for the IP inputs/outputs<a class="headerlink" href="#allocating-buffers-for-the-ip-inputs-outputs" title="Permalink to this headline">¶</a></h3>
<p>Similar to XRT managed kernel <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> objects are used to create buffers for IP ports. However, the memory bank location must be specified explicitly by providing enumerated index of the memory bank.</p>
<p>Below is a example of creating two buffers. Note the last argument of <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> is the enumerated index of the memory bank as seen by the XRT (in this example index 8 corresponds to the host-memory bank). The bank index can be obtained by <code class="docutils literal notranslate"><span class="pre">xbutil</span> <span class="pre">examine</span> <span class="pre">--report</span> <span class="pre">memory</span></code> command.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">35 </span>     <span class="k">auto</span> <span class="n">buf_in_a</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DATA_SIZE</span><span class="p">,</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">host_only</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="lineno">36 </span>     <span class="k">auto</span> <span class="n">buf_in_b</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DATA_SIZE</span><span class="p">,</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">host_only</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="reading-and-write-cu-mapped-registers">
<h3>Reading and write CU mapped registers<a class="headerlink" href="#reading-and-write-cu-mapped-registers" title="Permalink to this headline">¶</a></h3>
<p>To read and write from the AXI-Lite register space to a CU (specified by <code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code> object in the host code), the required member functions from the <code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code> class are</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::ip::read_register</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::ip::write_register</span></code></p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">35 </span>     <span class="kt">int</span> <span class="n">read_data</span><span class="p">;</span>
<span class="lineno">36 </span>     <span class="kt">int</span> <span class="n">write_data</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="lineno">37 </span>
<span class="lineno">38 </span>     <span class="k">auto</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">ip</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="s">&quot;foo:{foo_1}&quot;</span><span class="p">);</span>
<span class="lineno">39 </span>
<span class="lineno">40 </span>     <span class="n">read_data</span> <span class="o">=</span> <span class="n">ip</span><span class="p">.</span><span class="n">read_register</span><span class="p">(</span><span class="n">READ_OFFSET</span><span class="p">);</span>
<span class="lineno">41 </span>     <span class="n">ip</span><span class="p">.</span><span class="n">write_register</span><span class="p">(</span><span class="n">WRITE_OFFSET</span><span class="p">,</span><span class="n">write_data</span><span class="p">);</span>
</pre></div>
</div>
<p>In the above code block</p>
<ul class="simple">
<li><p>The CU named “foo_1” (name syntax: “kernel_name:{cu_name}”) is opened exclusively.</p></li>
<li><p>The Register Read/Write operation is performed.</p></li>
</ul>
</div>
</div>
<div class="section" id="graph">
<h2>Graph<a class="headerlink" href="#graph" title="Permalink to this headline">¶</a></h2>
<p>In Versal ACAPs with AI Engines, the XRT Graph class (<code class="docutils literal notranslate"><span class="pre">xrt::graph</span></code>) and its member functions can be used to dynamically load, monitor, and control the graphs executing on the AI Engine array.</p>
<p><strong>A note regarding Device and Buffer</strong>: In AIE based application, the device and buffer have some additional functionlities. For this reason the classes <code class="docutils literal notranslate"><span class="pre">xrt::aie::device</span></code> and <code class="docutils literal notranslate"><span class="pre">xrt::aie::buffer</span></code> are recommended to specify device and buffer objects.</p>
<div class="section" id="graph-opening-and-closing">
<h3>Graph Opening and Closing<a class="headerlink" href="#graph-opening-and-closing" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::graph</span></code> object can be opened using the uuid of the currently loaded XCLBIN file as shown below</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="lineno">35 </span>     <span class="k">auto</span> <span class="n">xclbin_uuid</span> <span class="o">=</span> <span class="n">device</span><span class="p">.</span><span class="n">load_xclbin</span><span class="p">(</span><span class="s">&quot;kernel.xclbin&quot;</span><span class="p">);</span>
<span class="lineno">36 </span>     <span class="k">auto</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">graph</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="s">&quot;graph_name&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The graph object can be used to execute the graph function on the AIE tiles.</p>
</div>
<div class="section" id="reset-functions">
<h3>Reset Functions<a class="headerlink" href="#reset-functions" title="Permalink to this headline">¶</a></h3>
<p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::reset()</span></code> is used to reset a specified graph by disabling tiles and enabling tile reset.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="lineno">45 </span>     <span class="k">auto</span> <span class="n">device</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">aie</span><span class="o">::</span><span class="n">device</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="lineno">46 </span>
<span class="lineno">47 </span>     <span class="c1">// load XCLBIN</span>
<span class="lineno">48 </span>     <span class="p">...</span>
<span class="lineno">49 </span>
<span class="lineno">50 </span>     <span class="k">auto</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">graph</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="s">&quot;graph_name&quot;</span><span class="p">);</span>
<span class="lineno">51 </span>     <span class="c1">// Graph Reset</span>
<span class="lineno">52 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</pre></div>
</div>
<p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::aie::device::reset_array()</span></code> is used to reset the whole AIE array. But after this AIE reset functionality is called, the PDI get lost, so a special AIE only XCLBIN has be loaded (This flow is for advanced user only).</p>
</div>
<div class="section" id="graph-execution">
<h3>Graph execution<a class="headerlink" href="#graph-execution" title="Permalink to this headline">¶</a></h3>
<p>XRT provides basic graph execution control interfaces to initialize, run, wait, and terminate graphs for a specific number of iterations. Below we will review some of the common graph execution styles.</p>
<div class="section" id="graph-execution-for-a-fixed-number-of-iterations">
<h4>Graph execution for a fixed number of iterations<a class="headerlink" href="#graph-execution-for-a-fixed-number-of-iterations" title="Permalink to this headline">¶</a></h4>
<p>A graph can be executed for a fixed number of iterations followed by a “busy-wait” or a “time-out wait”.</p>
<p><strong>Busy Wait scheme</strong></p>
<p>The graph can be executed for a fixed number of iteration by <code class="docutils literal notranslate"><span class="pre">xrt::graph::run()</span></code> API using an iteration argument. Subsequently, <code class="docutils literal notranslate"><span class="pre">xrt::graph::wait()</span></code> or <code class="docutils literal notranslate"><span class="pre">xrt::graph::end()</span></code> API should be used (with argument 0) to wait until graph execution is completed.</p>
<p>Let’s review the below example</p>
<ul>
<li><p>The graph is executed for 3 iterations by API <code class="docutils literal notranslate"><span class="pre">xrt::graph::run()</span></code> with the number of iterations as an argument.</p></li>
<li><p>The API <code class="docutils literal notranslate"><span class="pre">xrt::graph::wait(0)</span></code> is used to wait till the iteration is done.</p>
<blockquote>
<div><ul class="simple">
<li><p>The API <cite>xrt::graph::wait()</cite> is used because the host code needs to execute the graph again.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>The Graph is executed again for 5 iteration</p></li>
<li><p>The API <code class="docutils literal notranslate"><span class="pre">xrt::graph::end(0)</span></code> is used to wait till the iteration is done.</p>
<blockquote>
<div><ul class="simple">
<li><p>After <code class="docutils literal notranslate"><span class="pre">xrt::graph::end()</span></code> the same graph can not be executed.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="lineno">35 </span>     <span class="c1">// start from reset state</span>
<span class="lineno">36 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
<span class="lineno">37 </span>
<span class="lineno">38 </span>     <span class="c1">// run the graph for 3 iteration</span>
<span class="lineno">39 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="lineno">40 </span>
<span class="lineno">41 </span>     <span class="c1">// Wait till the graph is done</span>
<span class="lineno">42 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// Use graph::wait if you want to execute the graph again</span>
<span class="lineno">43 </span>
<span class="lineno">44 </span>
<span class="lineno">45 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="lineno">46 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// Use graph::end if you are done with the graph execution</span>
</pre></div>
</div>
<p><strong>Timeout wait scheme</strong></p>
<p>As shown in the above example <code class="docutils literal notranslate"><span class="pre">xrt::graph::wait(0)</span></code> performs a busy-wait and suspend the execution till the graph is not done. If desired a timeout version of the wait can be achieved by <code class="docutils literal notranslate"><span class="pre">xrt::graph::wait(std::chrono::milliseconds)</span></code> which can be used to wait for some specified number of milliseconds, and if the graph is not done do something else in the meantime. An example is shown below</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">35 </span>     <span class="c1">// start from reset state</span>
<span class="lineno">36 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
<span class="lineno">37 </span>
<span class="lineno">38 </span>     <span class="c1">// run the graph for 100 iteration</span>
<span class="lineno">39 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="lineno">40 </span>
<span class="lineno">41 </span>      <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">42 </span>
<span class="lineno">43 </span>        <span class="k">try</span> <span class="p">{</span>
<span class="lineno">44 </span>           <span class="n">graph</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="lineno">45 </span>        <span class="p">}</span>
<span class="lineno">46 </span>        <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">47 </span>
<span class="lineno">48 </span>           <span class="k">if</span> <span class="p">(</span><span class="n">ex</span><span class="p">.</span><span class="n">code</span><span class="p">().</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="n">ETIME</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">49 </span>
<span class="lineno">50 </span>              <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Timeout, reenter......&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="lineno">51 </span>              <span class="c1">// Do something</span>
<span class="lineno">52 </span>
<span class="lineno">53 </span>           <span class="p">}</span>
<span class="lineno">54 </span>       <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="infinite-graph-execution">
<h4>Infinite Graph Execution<a class="headerlink" href="#infinite-graph-execution" title="Permalink to this headline">¶</a></h4>
<p>The graph runs infinitely if <code class="docutils literal notranslate"><span class="pre">xrt::graph::run()</span></code> is called with iteration argument 0. While a graph running infinitely the APIs <code class="docutils literal notranslate"><span class="pre">xrt::graph::wait()</span></code>, <code class="docutils literal notranslate"><span class="pre">xrt::graph::suspend()</span></code> and <code class="docutils literal notranslate"><span class="pre">xrt::graph::end()</span></code> can be used to suspend/end the graph operation after some number of AIE cycles. The API <code class="docutils literal notranslate"><span class="pre">xrt::graph::resume()</span></code> is used to execute the infinitely running graph again.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="lineno">39 </span>     <span class="c1">// start from reset state</span>
<span class="lineno">40 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
<span class="lineno">41 </span>
<span class="lineno">42 </span>     <span class="c1">// run the graph infinitely</span>
<span class="lineno">43 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="lineno">44 </span>
<span class="lineno">45 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>  <span class="c1">// Suspends the graph after 3000 AIE cycles from the previous start</span>
<span class="lineno">46 </span>
<span class="lineno">47 </span>
<span class="lineno">48 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span> <span class="c1">// Restart the suspended graph again to run forever</span>
<span class="lineno">49 </span>
<span class="lineno">50 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">suspend</span><span class="p">();</span> <span class="c1">// Suspend the graph immediately</span>
<span class="lineno">51 </span>
<span class="lineno">52 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span> <span class="c1">// Restart the suspended graph again to run forever</span>
<span class="lineno">53 </span>
<span class="lineno">54 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>  <span class="c1">// End the graph operation after 5000 AIE cycles from the previous start</span>
</pre></div>
</div>
<p>In the example above</p>
<ul>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::run(0)</span></code> is used to execute the graph infinitely</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::wait(3000)</span></code> suspends the graph after 3000 AIE cycles from the graph starts.</p>
<blockquote>
<div><ul class="simple">
<li><p>If the graph was already run more than 3000 AIE cycles the graph is suspended immediately.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::resume()</span></code> is used to restart the suspended graph</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::suspend()</span></code> is used to suspend the graph immediately</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::end(5000)</span></code> is  ending the graph after 5000 AIE cycles from the previous graph start.</p>
<blockquote>
<div><ul class="simple">
<li><p>If the graph was already run more than 5000 AIE cycles the graph ends immediately.</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">xrt::graph::end()</span></code> eliminates the capability of rerunning the Graph (without loading PDI and a graph reset again).</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="measuring-aie-cycle-consumed-by-the-graph">
<h3>Measuring AIE cycle consumed by the Graph<a class="headerlink" href="#measuring-aie-cycle-consumed-by-the-graph" title="Permalink to this headline">¶</a></h3>
<p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::get_timestamp()</span></code> can be used to determine AIE cycle consumed between a graph start and stop.</p>
<p>Here in this example, the AIE cycle consumed by 3 iteration is calculated</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">35 </span>     <span class="c1">// start from reset state</span>
<span class="lineno">36 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
<span class="lineno">37 </span>
<span class="lineno">38 </span>     <span class="kt">uint64_t</span> <span class="n">begin_t</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">get_timestamp</span><span class="p">();</span>
<span class="lineno">39 </span>
<span class="lineno">40 </span>     <span class="c1">// run the graph for 3 iteration</span>
<span class="lineno">41 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="lineno">42 </span>
<span class="lineno">43 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="lineno">44 </span>
<span class="lineno">45 </span>     <span class="kt">uint64_t</span> <span class="n">end_t</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">get_timestamp</span><span class="p">();</span>
<span class="lineno">46 </span>
<span class="lineno">47 </span>     <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Number of AIE cycles consumed in the 3 iteration is: &quot;</span><span class="o">&lt;&lt;</span> <span class="n">end_t</span><span class="o">-</span><span class="n">begin_t</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="rtp-runtime-parameter-control">
<h3>RTP (Runtime Parameter) control<a class="headerlink" href="#rtp-runtime-parameter-control" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::graph</span></code> class contains member function to update and read the runtime parameters of the graph.</p>
<ul class="simple">
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::update()</span></code> to update the RTP</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::read()</span></code> to read the RTP.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">35 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
<span class="lineno">36 </span>
<span class="lineno">37 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="lineno">38 </span>
<span class="lineno">39 </span>     <span class="kt">float</span> <span class="n">increment</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="lineno">40 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="s">&quot;mm.mm0.in[2]&quot;</span><span class="p">,</span> <span class="n">increment</span><span class="p">);</span>
<span class="lineno">41 </span>
<span class="lineno">42 </span>     <span class="c1">// Do more things</span>
<span class="lineno">43 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
<span class="lineno">44 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="lineno">45 </span>
<span class="lineno">46 </span>     <span class="c1">// Read RTP</span>
<span class="lineno">47 </span>     <span class="kt">float</span> <span class="n">increment_out</span><span class="p">;</span>
<span class="lineno">48 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="s">&quot;mm.mm0.inout[0]&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">increment_out</span><span class="p">);</span>
<span class="lineno">49 </span>     <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s"> RTP value read&lt;&lt;increment_out;</span>
</pre></div>
</div>
<p>In the above example, the member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::update()</span></code> and <code class="docutils literal notranslate"><span class="pre">xrt::graph::read()</span></code> are used to update and read the RTP values respectively. Note the function arguments</p>
<ul class="simple">
<li><p>The hierarchical name of the RTP port</p></li>
<li><p>Variable to set/read the RTP</p></li>
</ul>
</div>
<div class="section" id="dma-operation-to-and-from-global-memory-io">
<h3>DMA operation to and from Global Memory IO<a class="headerlink" href="#dma-operation-to-and-from-global-memory-io" title="Permalink to this headline">¶</a></h3>
<p>The AIE buffer class <code class="docutils literal notranslate"><span class="pre">xrt::aie::bo</span></code> supports member function <code class="docutils literal notranslate"><span class="pre">xrt::aie::bo::sync()</span></code> that can be used to synchronize the buffer contents between global memory and AIE. The following code shows a sample example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">35 </span>     <span class="k">auto</span> <span class="n">device</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">aie</span><span class="o">::</span><span class="n">device</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="lineno">36 </span>
<span class="lineno">37 </span>     <span class="c1">// Buffer from global memory (GM) to AIE</span>
<span class="lineno">38 </span>     <span class="k">auto</span> <span class="n">in_bo</span>  <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">aie</span><span class="o">::</span><span class="n">bo</span> <span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">SIZE</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="lineno">39 </span>
<span class="lineno">40 </span>     <span class="c1">// Buffer from AIE to global memory (GM)</span>
<span class="lineno">41 </span>     <span class="k">auto</span> <span class="n">out_bo</span>  <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">aie</span><span class="o">::</span><span class="n">bo</span> <span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">SIZE</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="lineno">42 </span>
<span class="lineno">43 </span>     <span class="k">auto</span> <span class="n">inp_bo_map</span> <span class="o">=</span> <span class="n">in_bo</span><span class="p">.</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">float</span> <span class="o">*&gt;</span><span class="p">();</span>
<span class="lineno">44 </span>     <span class="k">auto</span> <span class="n">out_bo_map</span> <span class="o">=</span> <span class="n">out_bo</span><span class="p">.</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">float</span> <span class="o">*&gt;</span><span class="p">();</span>
<span class="lineno">45 </span>
<span class="lineno">46 </span>     <span class="c1">// Prepare input data</span>
<span class="lineno">47 </span>     <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">my_float_array</span><span class="p">,</span><span class="n">my_float_array</span><span class="o">+</span><span class="n">SIZE</span><span class="p">,</span><span class="n">inp_bo_map</span><span class="p">);</span>
<span class="lineno">48 </span>
<span class="lineno">49 </span>
<span class="lineno">50 </span>     <span class="n">in_bo</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="s">&quot;in_sink&quot;</span><span class="p">,</span> <span class="n">XCL_BO_SYNC_BO_GMIO_TO_AIE</span><span class="p">,</span> <span class="n">SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="mi">0</span><span class="p">);</span>
<span class="lineno">51 </span>
<span class="lineno">52 </span>     <span class="n">out_bo</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="s">&quot;out_sink&quot;</span><span class="p">,</span> <span class="n">XCL_BO_SYNC_BO_AIE_TO_GMIO</span><span class="p">,</span> <span class="n">SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>The above code shows</p>
<ul>
<li><p>Input and output buffer (<code class="docutils literal notranslate"><span class="pre">in_bo</span></code> and <code class="docutils literal notranslate"><span class="pre">out_bo</span></code>) to the graph are created and mapped to the user space</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::aie::bo::sync</span></code> is used for data transfer using the following arguments</p>
<blockquote>
<div><ul>
<li><p>The name of the GMIO ports associated with the DMA transfer</p></li>
<li><p>The direction of the buffer transfer</p>
<blockquote>
<div><ul class="simple">
<li><p>GMIO to Graph: <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_GMIO_TO_AIE</span></code></p></li>
<li><p>Graph to GMIO: <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_AIE_TO_GMIO</span></code></p></li>
</ul>
</div></blockquote>
</li>
<li><p>The size and the offset of the buffer</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="xrt-error-api">
<h2>XRT Error API<a class="headerlink" href="#xrt-error-api" title="Permalink to this headline">¶</a></h2>
<p>In general, XRT APIs can encounter two types of errors:</p>
<ul class="simple">
<li><p>Synchronous error: Error can be thrown by the API itself. The host code can catch these exception and take necessary steps.</p></li>
<li><p>Asynchronous error: Errors from the underneath driver, system, hardware, etc.</p></li>
</ul>
<p>XRT provides an <code class="docutils literal notranslate"><span class="pre">xrt::error</span></code> class and its member functions to retrieve the asynchronous errors into the userspace host code. This helps to debug when something goes wrong.</p>
<ul class="simple">
<li><p>Member function <code class="docutils literal notranslate"><span class="pre">xrt::error::get_error_code()</span></code> - Gets the last error code and its timestamp of a given error class</p></li>
<li><p>Member function <code class="docutils literal notranslate"><span class="pre">xrt::error::get_timestamp()</span></code> - Gets the timestamp of the last error</p></li>
<li><p>Member function <code class="docutils literal notranslate"><span class="pre">xrt:error::to_string()</span></code> - Gets the description string of a given error code.</p></li>
</ul>
<p><strong>NOTE</strong>: The asynchronous error retrieving APIs are at an early stage of development and only supports AIE related asynchronous errors. Full support for all other asynchronous errors is planned in a future release.</p>
<p>Example code</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="lineno">41 </span>     <span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">runInteration</span><span class="p">);</span>
<span class="lineno">42 </span>
<span class="lineno">43 </span>     <span class="k">try</span> <span class="p">{</span>
<span class="lineno">44 </span>        <span class="n">graph</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
<span class="lineno">45 </span>     <span class="p">}</span>
<span class="lineno">46 </span>     <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">47 </span>
<span class="lineno">48 </span>        <span class="k">if</span> <span class="p">(</span><span class="n">ex</span><span class="p">.</span><span class="n">code</span><span class="p">().</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="n">ETIME</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">49 </span>           <span class="n">xrt</span><span class="o">::</span><span class="n">error</span> <span class="n">error</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">XRT_ERROR_CLASS_AIE</span><span class="p">);</span>
<span class="lineno">50 </span>
<span class="lineno">51 </span>           <span class="k">auto</span> <span class="n">errCode</span> <span class="o">=</span> <span class="n">error</span><span class="p">.</span><span class="n">get_error_code</span><span class="p">();</span>
<span class="lineno">52 </span>           <span class="k">auto</span> <span class="n">timestamp</span> <span class="o">=</span> <span class="n">error</span><span class="p">.</span><span class="n">get_timestamp</span><span class="p">();</span>
<span class="lineno">53 </span>           <span class="k">auto</span> <span class="n">err_str</span> <span class="o">=</span> <span class="n">error</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span>
<span class="lineno">54 </span>
<span class="lineno">55 </span>           <span class="cm">/* code to deal with this specific error */</span>
<span class="lineno">56 </span>           <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">err_str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="lineno">57 </span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="lineno">58 </span>         <span class="cm">/* Something else */</span>
<span class="lineno">59 </span>        <span class="p">}</span>
<span class="lineno">60 </span>     <span class="p">}</span>
</pre></div>
</div>
<p>The above code shows</p>
<ul class="simple">
<li><p>After timeout occurs from <code class="docutils literal notranslate"><span class="pre">xrt::graph::wait()</span></code> the member functions <code class="docutils literal notranslate"><span class="pre">xrt::error</span></code> class are called to retrieve asynchronous error code and timestamp</p></li>
<li><p>Member function <code class="docutils literal notranslate"><span class="pre">xrt::error::to_string()</span></code> is called to obtain the error string.</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
<!-- Atalwar: Moved the footer code to layout.html to resolve conflict with the Xilinx template -->
</footer>

        </div>
      </div>
	  
	  
	  <!-- Sphinx Page Footer block -->
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="xrt_native.main.html" class="btn btn-neutral float-right" title="XRT Native Library C++ API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="opencl_extension.html" class="btn btn-neutral float-left" title="Xilinx OpenCL extension" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo" class="copyright">
    <p class="footerinfo">
      <span class="lastupdated">
        Last updated on June 08, 2021.
      </span>

    </p>
  </div>	  
      </div>
    </section>


  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

   <script type="text/javascript">
    jQuery(function() { Search.loadIndex("searchindex.js"); });
  </script>

  <script type="text/javascript" id="searchindexloader"></script>     	    
	    
	    
  
  
    
  
  

  
  <!--  Xilinx template footer block -->
							</div>
						</div>
					</div>
				</div>
				<div class="xilinxExperienceFragments experiencefragment aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16">
					<div class="xf-content-height">
						<div class="aem-Grid aem-Grid--16 aem-Grid--default--16 ">
							<div class="footer parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16">
								<noindex>
									<footer>
										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">
													<div class="row">
														<div class="footerSocial parbase">
															<div class="col-md-push-6 col-lg-push-6 col-md-6 col-lg-6">
																<ul class="list-inline pull-right social-menu">
																	<li>
																		<a href="https://www.linkedin.com/company/xilinx">
																		<span class="linkedin icon"></span>
																		<span class="sr-only">Connect on LinkedIn</span>
																		</a>
																	</li>
																	<li>
																		<a href="https://www.twitter.com/XilinxInc">
																		<span class="twitter icon"></span>
																		<span class="sr-only">Follow us on Twitter</span>
																		</a>
																	</li>
																	<li>
																		<a href="https://www.facebook.com/XilinxInc">
																		<span class="facebook icon"></span>
																		<span class="sr-only">Connect on Facebook</span>
																		</a>
																	</li>
																	<li>
																		<a href="https://www.youtube.com/XilinxInc">
																		<span class="youtube icon"></span>
																		<span class="sr-only">Watch us on YouTube</span>
																		</a>
																	</li>
																	<li>
																		<a href="https://www.xilinx.com/registration/subscriber-signup.html">
																		<span class="newsletter icon"></span>
																		<span class="sr-only">Subscribe to Newsletter</span>
																		</a>
																	</li>
																</ul>
															</div>
														</div>
														<div class="col-md-pull-6 col-lg-pull-6 col-md-6 col-lg-6">
															<span class="copyright">
                                  
                                  &copy; 2017-2021, Xilinx, Inc.
                              </span>
															<ul class="list-inline sub-menu">
																<li>
																	<a href="https://www.xilinx.com/about/privacy-policy.html">Privacy</a>
																</li>
																<li>
																	<a href="https://www.xilinx.com/about/legal.html">Legal</a>
																</li>
																<li>
																	<a href="https://www.xilinx.com/about/contact.html">Contact</a>
																</li>
															</ul>
														</div>
													</div>
												</div>
											</div>
										</div>
									</footer>
								</noindex>
							</div>
						</div>
					</div>
				</div>
				<div class="quicklinks parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16">
					<noindex>
						<span class="quickLinks">
							<ul>
								<li>
									<a href="#top" class="btn backToTop">
									<span class="fas fa-angle-up" aria-hidden="true"></span>
									</a>
								</li>
							</ul>
						</span>
					</noindex>
				</div>
			</div>
		</div>
		<script>window.CQ = window.CQ || {}</script>
		<script src="https://static.cloud.coveo.com/searchui/v2.4382/js/CoveoJsSearch.Lazy.min.js"></script>
		<script>
			var underscoreSetup = function () {
			  _.templateSettings.interpolate = /\{\{=([^-][\S\s]+?)\}\}/g;
			  _.templateSettings.evaluate = /\{\{([^-=][\S\s]+?)\}\}/g;
			  _.templateSettings.escape = /\{\{-([^=][\S\s]+?)\}\}/g;
			}
			
			underscoreSetup();
		</script>
	</body>
</html>